---
title: "Clean up gating"
author: "Anja Br√•then Kristoffersen"
date: "08 March 2022"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This document describes the different lines of the file "example clean up gating alle filer.R". To perform your own gating save the file "example clean up gating alle filer.R" from github https://github.com/folkehelseinstituttet/cytof give it a new name and change the necessary paths and values throughout the document to use it on your own data. 


You start with defining a variable data_path that contains the path of the folder where all your uncleaned files are saved. I prefer using the function path from the library fs. When using a function from a given library the way to get the function is by library_name::function_name so in this case fs::path 


```{r}
data_path <- fs::path("F:", "Forskningsprosjekter", "PDB 2794 - Immune responses aga_", "Forskningsfiler", "JOBO", "CyTOF","Datafiles", "Panel 1 all files")
```

which gives the path

```{r}
data_path
```

Now define the paths to the folder where you want to save 

 * the new files that are clean up gated and 
 * figures of the gating performance. 
 
Do also define the path where the files script used are saved.
```{r}
outDataPath <- fs::path("F:", "Forskningsprosjekter", "PDB 2794 - Immune responses aga_", "Forskningsfiler", "JOBO", "CyTOF", "Analyse i R OUS", "CleanUpGatingMarch2022", "gating_results_Panel1_mars2022", "clean data")
scriptPath <- fs::path("H:", "git", "cytof")
out_result <- fs::path("F:", "Forskningsprosjekter", "PDB 2794 - Immune responses aga_", "Forskningsfiler", "JOBO", "CyTOF","Analyse i R OUS", "CleanUpGatingMarch2022", "gating_results_Panel1_mars2022")
outFigSignalPath <- fs::path("F:", "Forskningsprosjekter", "PDB 2794 - Immune responses aga_", "Forskningsfiler", "JOBO", "CyTOF","Analyse i R OUS", "CleanUpGatingMarch2022", "gating_results_Panel1_mars2022", "FigSignal")
outFigDensityPath <- fs::path("F:", "Forskningsprosjekter", "PDB 2794 - Immune responses aga_", "Forskningsfiler", "JOBO", "CyTOF","Analyse i R OUS", "CleanUpGatingMarch2022", "gating_results_Panel1_mars2022", "FigDensity")
```

I have already made many functions that can be used for reading, transforming, gating, plotting and analysing in R. These functions can be found on github https://github.com/folkehelseinstituttet/cytof. Save the files gating_functions.R, ploting_functions, read_data_function.R, analysis_functions.R and transformation_functions.R into your script folder and source them into R so that you might use them later

```{r, include = F}
#idea; maybe make one great file? 
```


```{r}
source(fs::path(scriptPath,  "read_data_functions.R"))
source(fs::path(scriptPath,  "transformation_functions.R"))
source(fs::path(scriptPath,  "ploting_functions.R"))
source(fs::path(scriptPath,  "clustering_functions.R"))
source(fs::path(scriptPath,  "gating_functions.R"))
source(fs::path(scriptPath,  "analysis_functions.R"))
```

file.info() and list.files() are functions in R that can be  used to find the name of all files in one folder 

```{r}
fcs_files <- fs::path(data_path, rownames(file.info(list.files(data_path))))
```

I here choose to only look at six files, which is. 

```{r}
fcs_files[c(1, 11, 21, 31, 41, 51)]
fcs_files <- fcs_files[c(1, 11, 21, 31, 41, 51)]
```

basename() is a function that give you the name of the file without the path. By using the function grepl() we choose only the files that contains .fcs. 

```{r}
files_to_open <- basename(fcs_files)
files_to_open <- files_to_open[grepl(".fcs", files_to_open)]
```

setwd() is a function who set the working directory. Here we want the working directory to be where the uncleaned cytof files are. dirname() gives the directory/folder of one file, and fcs_files[1] gives the first file in the vector fcs_files.

```{r}
setwd(dirname(fcs_files[1]))
```

The variable file_names are made as a shorter version of the variable files_to_open (without ".fcs") by using the function gsub(), the function gsub() first takes the pattern that you want to substitute and then the pattern you want to replace it with in the vector which is the last variable in the function call. This is done to have shorter unique names on each dataset/file for later use. 

```{r}
file_names <- gsub(".fcs", "", files_to_open)
```

The number of .fcs files in the variable vector file_names are found by the function length()

```{r}
n_files <- length(file_names)
```

Here a vector filenumbers containing 1, 2, 3, .... to n_files are made for later use

```{r}
filenumbers <- 1:n_files
filenumbers
```

Two empty matrixes to take care of how many percentages of each file that are lost by each gating and in total of all previous gating are defined as percent_lost_each_gating and percent_lost_from_full_dataset, respectively. These data.frames are given the column name of the gating and the rownames of the files that are gated.

```{r}
percent_lost_each_gating <- as.data.frame(matrix(NA, ncol = 9, nrow = n_files))
percent_lost_from_full_dataset <-   as.data.frame(matrix(NA, ncol = 9, nrow = n_files))

colnames(percent_lost_each_gating) <- c("Ce140Di", "Residual", "Center", "Offset", "Width",
                                        "Event_length", "Pt194Di", "Ir191Di", "Ir193Di")

colnames(percent_lost_from_full_dataset) <- colnames(percent_lost_each_gating)

rownames(percent_lost_each_gating) <- file_names
rownames(percent_lost_from_full_dataset) <- rownames(percent_lost_each_gating)

```


plotSignal() is a function that has to be made to the dataset that are used. It tells how to plot the files you use. Here I have 6 files and I want to plot them with 2 rows and 3 columns. The variable plot_list is a list that I will produce later that contain a plot per file. To write comments into an R code you use # in the beginning of the line. I have here written a version of this function that plots 66 plots in 6 rows and 11 columns.

```{r}
plotSignal <- function(plot_list){
  g <- gridExtra::grid.arrange(plot_list[[1]], plot_list[[2]], plot_list[[3]], plot_list[[4]], plot_list[[5]],
                          plot_list[[6]], ncol = 3, nrow = 2)
  return(g)
}
# plotSignal <- function(plot_list){
# g <- gridExtra::grid.arrange(plot_list[[1]], plot_list[[2]], 
#              plot_list[[3]], plot_list[[4]], plot_list[[5]],
#              plot_list[[6]],  plot_list[[7]], plot_list[[8]], 
#              plot_list[[9]], plot_list[[10]], plot_list[[11]], 
#              plot_list[[12]], plot_list[[13]], plot_list[[14]], 
#              plot_list[[15]], plot_list[[16]], plot_list[[17]], 
#              plot_list[[18]], plot_list[[19]], plot_list[[20]],
#              plot_list[[21]], plot_list[[22]], plot_list[[23]], 
#              plot_list[[24]], plot_list[[25]], plot_list[[26]],
#              plot_list[[27]], plot_list[[28]], plot_list[[29]],
#              plot_list[[30]], plot_list[[31]], plot_list[[32]], 
#              plot_list[[33]], plot_list[[34]], plot_list[[35]],
#              plot_list[[36]], plot_list[[37]], plot_list[[38]], 
#              plot_list[[39]], plot_list[[40]], plot_list[[41]], 
#              plot_list[[42]], plot_list[[43]], plot_list[[44]], 
#              plot_list[[45]], plot_list[[46]], plot_list[[47]], 
#              plot_list[[48]], plot_list[[49]], plot_list[[50]],
#              plot_list[[51]], plot_list[[52]], plot_list[[53]], 
#              plot_list[[54]], plot_list[[55]], plot_list[[56]],  
#              plot_list[[57]], plot_list[[58]], plot_list[[59]], 
#              plot_list[[60]], plot_list[[61]], plot_list[[62]], 
#              plot_list[[63]], plot_list[[64]], plot_list[[65]],
#              plot_list[[66]],  ncol = 11, nrow = 6)
#    return(g)
# }
```


```{r, include = FALSE}
# If because of memory problems the data cleaning has to be done in groups this is an exampel of how to replace i below. (if using for-loop it can not be devided into script parts as below but rather on big unit as in example clean up gating alle filer.R)
#for(ii in 1:floor(n_files/6)){
#  
#  i <- filenumber[((ii-1) * 6 + (1:6))]
#  i <- i[!is.na(i)]
```

You could either look at all files at the same time or divide it into blocks of files. Here is an example with all files. If memory problems, it is possible to divide the files to clean into groups using a loop. 


Read all files in data_path into a list object fcs_data by using the function read_some_data_from_folder(). This function returns two elements the dataset and the file_name in the same order as the data is read. I choose to store this in two separate variables and remove the variable with both objects by using the function rm().

```{r}
fcs_data_with_info <- read_some_data_from_folder(data_path, file_number = filenumbers)
fcs_data <- fcs_data_with_info$fcs_data
file_names <- factor(fcs_data_with_info$file_names, levels = fcs_data_with_info$file_names)
rm(fcs_data_with_info)
```

By using the function get_params_fcs_data() the parameters of the first element of the list fcs_data are obtained. By writing the variable name params we get to see what this variable contains. 

```{r}
params <- get_params_fcs_data(fcs_data[[1]])
params
```

Now that we have read all the data into R we are ready for gating so that we are left with only live cells. 

## Beads gating

Beads channels can be "Ce140Di", "Eu151Di", "Eu153Di", "Ho165Di" or "Lu175Di" or maybe something else in your dataset. Here we use the function grepl() to get the correct name used in params. the string "140|151|153|165|175" tells grepl() to look for 140, 151, 153, 165 or 175 in the column name of the data.frame params. R is case sensitive, so it is important to write the name correctly.

```{r}
#***************************************************
#gating on Beads ----
#***************************************************
bead_channels <- as.character(params$name[grepl("140|151|153|165|175", params$name)])
bead_channels
```
here we choose to do the beads gating on Ce140Di, first making the list beads_data where I have arc_sinh transformed the signal data. 

```{r}
x <- "Ce140Di"
beads_data <-  arc_sinh_transform_selected_channels(fcs_data = fcs_data, channels = bead_channels)
```

The variable beads_data is a list that contain as many elements as fcs file used

```{r}
length(beads_data)
```
where each element in the list contains a matrix with the observation of that file. By using the function head() we can look at the six first rows in the first element ([[1]]) in the list beads_data

```{r}
head(beads_data[[1]])
```

by using the function number_of_events_raw_data() we get a vector with number of events in the dataset

```{r}
number_of_events_raw_data <-  number_of_events(data = fcs_data, file_names = file_names)
number_of_events_raw_data
```

since it takes time and memory to plot many events, we here choose to randomly plot 10000 events per file. This events are found by the function random_events() which gives a list of as many elements that you have files. Each element of the list  contains a vector with 10000 numbers representing the events to plot. 

```{r}
random_events_for_plotting <- random_events(number_of_events_raw_data, n = 10000)
```

When performing beads gating the purpose is to exclude events with high signal. 

Here the function  find_gate_perc_height_upper_noise() takes the dataset that you want to make the gates based on, here beads_data in column channel x, and a value upper_perc_height, here 0.001, the proportion height of the max of the density curve. The max of the density curve is here shown with the red line. while 0.001 times this height is shown with the green line. The gate should be placed where the green horizontal line crosses the density curve. Here shown by the green vertical line. The function find_gate_perc_height_upper_noise() take a list of matrices and return a vector in the same length as the list, i.e. one gate per file. 

```{r, echo  = F, width = 12, height =5}
#example only in word document to show how the function work.
signal <- beads_data[[1]][, x]
dens <- density(signal)
posible <- dens$y > max(dens$y) * 0.001
xposible <- which(posible[2:length(posible)] - posible[1:(length(posible)-1)] == -1)[1]
value <- dens$x[xposible]
y_max <- max(dens$y)
x_max <- dens$x[which(dens$y == y_max)]


plot(dens, lwd =3)
abline(h = y_max, col = "red", lwd = 2)
abline(h = dens$y[xposible], col = "green")
lines(c(value, value), c(0,1), col ="green", lwd = 2)


##NB forandr navn p√• funksjon til prop ikke perc


```




Here we use the function find_gate_perc_height_upper_noise() to find upper_gate for noise gating based on the channel Ce140Di. The upper_gate values are stored in the variable upper_gate_Ce140Di. 


```{r}
upper_gate_Ce140Di <- find_gate_perc_height_upper_noise(data = beads_data, channel = x, upper_perc_height = 0.001)
```

Then we make a time signal plot where the signal is plotted against time and the gate is shown. Even though we here only make the plot for those events we want to plot, saved in random_events_for_plotting, the gate is made on all datapoints. 

```{r}
time_signal_plots <- time_signal_plot(data = beads_data, random_events = random_events_for_plotting, 
                                        channel = x,  plot_title = file_names, upper_gate = upper_gate_Ce140Di)
  
time_signal_plots[1] # to see first plot
```

All the plots can be plotted together by using the function plotSignal(). I prefer to save this plot to a tiff file instead of plotting it in R. In that way you have saved it to later evaluations. 

```{r}
plotSignal(plot_list = time_signal_plots)
```

I prefer to save this plot to a tiff file instead of plotting it in R. In that way you have saved it to later evaluations. To run the lines remove "#".

```{r}
# tiff(fs::path(outFigPath, "Signal_fig1_bead_gating.tiff"), width = 1800, height = 1200)
# plotSignal(plot_list = time_signal_plots)
# dev.off()
```


The gate could also be plotted in a density plot made by the function density_plot(). Again you could either see it directly in the RStudio or save it to a tiff file. If saving it, you do not have to run the script again to see what you did.  

```{r}
density_plots <- density_plot(data = beads_data, channel = x, plot_title = file_names, upper_gate = upper_gate_Ce140Di, maksCellsUsed = 25000)
density_plots # to see the plots
  
  
# tiff(fs::path(outFigPath, "fig1_bead_gating.tiff"), width = 1200, height = 2000)
# density_plots
# dev.off()
```


Before continuing with the script, it should be decided if the gate is ok  or something should be adjusted. 
If ok, proceed using the gate and adjust the dataset by excluding the events with signal above upper_gate_Ce140Di.

* The function events_to_keep_after_gating() find which events to keep per dataset. 
* The function update_data_based_on_events_to_keep() update the fcs_data
* The number of events per file after gating are found by number_of_events()
* The percentages lost by this gating and for full dataset is calculated and saved in the matrices percent_lost_from_full_dataset and percent_lost_from_full_dataset
* A new vector of random_events_for_plotting is made by the function random_events()


```{r}
events_to_keep_after_gating <- events_to_keep(data = beads_data, channel = "Ce140Di",  upper_gate = upper_gate_Ce140Di)
  
  #overwrite the raw  dataset (will take lot of space if we make one new each time, and do not need it)
  fcs_data <- update_data_based_on_events_to_keep(data = fcs_data, kept_events = events_to_keep_after_gating)
  number_of_events_after_gating <-  number_of_events(data = fcs_data, file_names = file_names)
  percent_lost_each_gating[as.character(file_names),"Ce140Di"] <- number_of_events_after_gating/number_of_events_raw_data * 100 
  percent_lost_from_full_dataset[as.character(file_names),"Ce140Di"] <- number_of_events_after_gating/number_of_events_raw_data * 100 
  random_events_for_plotting <- random_events(number_of_events_after_gating)
  
  
  number_of_events_after_beads_gating <- number_of_events_after_gating
```


The percent of events lost for this gating is saved in the matrix percent_lost_each_gating, and can be printed here as

```{r}
percent_lost_each_gating[as.character(file_names),"Ce140Di"]
```


Since we are finished working with beads_data, remove them to save space in memory

```{r}
rm(beads_data)
```

# clean_up_data
 
 * the clean up channel names can be found by using grep of the string "Center|Offset|Width|Residual|Event|Ir191|Ir193|Pt195Di|Pt194Di"
 * a arc_sinh transformed dataset with this channels are made using the function arc_sinh_transform_selected_channels()

 
```{r}
#************************************************
  #clean_up_data
  #************************************************
  clean_up_channels <- as.character(params$name[grep("Center|Offset|Width|Residual|Event|Ir191|Ir193|Pt195Di|Pt194Di", params$name)])  #Pt194Di og 195 tilsvarer Cis
  clean_up_data <-  arc_sinh_transform_selected_channels(fcs_data = fcs_data, channels = clean_up_channels)
```

to be able to calculate the number of events lost by this gating we make the variable number_of_events_before_clean_up_gating using the function number_of_events()

```{r}
number_of_events_before_clean_up_gating <-  number_of_events(data = fcs_data, file_names = file_names)
```

# Gating on Residual


The first clean up gating is on residuals.

First the number of events left before this gating are found and a new set random cells for plotting made.


```{r}
 #************************************************
  #gating on Residual+ ----
  #************************************************
  number_of_events_before_residual_gating <-  number_of_events(data = fcs_data, file_names = file_names)
  random_events_for_plotting <- random_events(number_of_events_before_residual_gating)
```


Here the function find_gaussian_gates_second_top() takes the dataset that you want to make the gates based on, here clean_up_data in column channel "Residual", and two values lower_perc_height and upper_perc_height, here 10 and 10, the percentage height of the max of the density curve. The maximum and minimum of the density curve is here shown with the red line, while the height between these lines are shown in blue. 0.1 times this height is shown with the green line. The gate should be placed where the green horizontal line crosses the density curve. Here shown by the green vertical lines. The function  find_gaussian_gates_second_top() take a list of matrices and return two vectors which both has the same length as the list, i.e. two gates per file. 



```{r, echo = FALSE, message= FALSE, comment= FALSE}


xx <- clean_up_data[[1]][, "Residual"]
dens <- density(xx)
ts_y<-ts(smooth(dens$y))
tp <- pastecs::turnpoints(ts_y)
# antar kun to h√∏yeste topper. 
#  mulig <- which(tp$peaks)
# mulig[order(dens$y[mulig], decreasing = T)]
sjekk <- tp$peaks
#dens$y[sjekk]
  
bunn_n <- min(max(which(tp$pits)[1]),  length(dens$y) - 1, na.rm = T)
top_n <-  bunn_n + min(which(dens$y[bunn_n:length(dens$y)] == max(dens$y[bunn_n:length(dens$y)]))[1],  length(bunn_n:length(dens$y)), na.rm = T) - 1 
# top_n <-  bunn_n + min(which(tp$peaks[bunn_n:length(dens$y)])[1], length(bunn_n:length(dens$y)), na.rm = T) - 1
#tp$peaks[top]
h <- dens$y[top_n] - dens$y[bunn_n]
lower_gate_prop <- 0.1
upper_gate_prop <- 0.1
cutoff_h_lower <- dens$y[bunn_n] + lower_gate_prop*h
cutoff_n_lower <- bunn_n + which(dens$y[bunn_n:length(dens$y)] > cutoff_h_lower)[1] - 1
lower_gate <- min(dens$x[cutoff_n_lower])
cutoff_h_upper <- dens$y[bunn_n] + upper_gate_prop*h
cutoff_n_upper <- bunn_n + which(dens$y[bunn_n:length(dens$y)] > cutoff_h_upper)[1] - 1
upper_gate <- max(dens$x[dens$y > max(dens$y) * upper_gate_prop])
  

plot(dens, lwd = 3, main = "density plot Residual", xlab = "arc sinh transformed signal")  
abline(v = dens$x[bunn_n], col = "red")
abline(v = dens$x[top_n], col = "red")
abline(h = dens$y[bunn_n], col = "red")
abline(h = dens$y[top_n], col = "red")
lines(c(6,6), c(dens$y[bunn_n], dens$y[top_n]), col = "blue")   
text(x = 6.2, y =dens$y[top_n] - (dens$y[top_n] - dens$y[bunn_n])*0.5, labels = "h", col = "blue")
abline(v = lower_gate, col = "green")
abline(h = dens$y[cutoff_n_lower], col = "green")
abline(v = upper_gate, col = "green")
abline(h = dens$y[cutoff_n_upper], col = "green")


```



The function find_gaussian_gates_second_top() are used to find lower and upper gate for the positiv signal of the residuals.
It takes the variables

  * data: here the arc sinh transformed clean_up_data are used
  * channel: which marker/channel you want to gate, here "Residual".
  * lower_gate_percent: tells where the lower gate is placed. See figure and explanation above, here 10 %
  * upper_gate_percent: tells where the upper gate is placed. See figure and explanation above, here 10 %




R code to fine the lower and upper residual gates:

```{r}
 residual_gates <- find_gaussian_gates_second_top(data = clean_up_data, channel = "Residual", lower_gate_percent = 10, upper_gate_percent = 10)
 
```

make a time signal plot where the signal is plotted against time and the gate is shown. 

```{r}
time_signal_plots <- time_signal_plot(data = clean_up_data, random_events = random_events_for_plotting, channel = "Residual", plot_title = file_names,  lower_gate = residual_gates$lower_gate, upper_gate = residual_gates$upper_gate)
  
time_signal_plots[1] # to see first plot
```

All the plots can be plotted together by using the function plotSignal(). 

```{r}
plotSignal(plot_list = time_signal_plots)
```

I prefer to save this plot to a tiff file instead of plotting it in R. In that way you have saved it to later evaluations. 

```{r}
# tiff(fs::path(outFigPath, "Signal_fig2_residal_gating.tiff"), width = 1800, height = 1200)
# plotSignal(plot_list = time_signal_plots)
# dev.off()
```


The gate could also be plotted in a density plot made by the function density_plot(). Again, you could either see it directly in the RStudio or save it to a tiff file. If saving it, you do not have to run the script again to see what you did.  

```{r}
density_plots <- density_plot(data = clean_up_data, "Residual", plot_title = file_names, lower_gate = residual_gates$lower_gate, upper_gate = residual_gates$upper_gate, maksCellsUsed = 25000)
density_plots # to see the plots
  
  
# tiff(fs::path(outFigPath, "fig1_bead_gating.tiff"), width = 1200, height = 2000)
# density_plots
# dev.off()
```


Before continuing with the script, it should be decided if the gate is ok  or something should be adjusted. 
If ok, proceed using the gate and adjust the dataset by excluding the events that do not have a signal between lower and upper residual gates. 

* The function events_to_keep_after_gating() find which events to keep per dataset. 
* The function update_data_based_on_events_to_keep() update the fcs_data and the clean_up_data
* The number of events per file after gating are found by number_of_events()
* The percentages lost by this gating and for full dataset is calculated and saved in the matrices percent_lost_from_full_dataset and percent_lost_from_full_dataset
* A new vector of random_events_for_plotting is made by the function random_events()


```{r}



  events_to_keep_after_gating <- events_to_keep(data = clean_up_data, channel = "Residual", lower_gate = residual_gates$lower_gates,
                                                upper_gate = residual_gates$upper_gate)

  fcs_data <- update_data_based_on_events_to_keep(data = fcs_data, kept_events = events_to_keep_after_gating)
  clean_up_data <- update_data_based_on_events_to_keep(data = clean_up_data, kept_events = events_to_keep_after_gating)
  number_of_events_after_residual_gating <-  number_of_events(data = fcs_data, file_names = file_names)
  percent_lost_from_full_dataset[as.character(file_names),"Residual"] <- number_of_events_after_residual_gating/number_of_events_raw_data * 100 #percent remaining from total
  percent_lost_each_gating[as.character(file_names),"Residual"] <- number_of_events_after_residual_gating/number_of_events_before_residual_gating * 100 #percent remaining from bead gating
```

The percent of events lost for this gating is 

```{r}
percent_lost_each_gating[as.character(file_names),"Residual"]
```

# Gating on Center


The second clean up gating is on center.

First the number of events left before this gating are found and a new set random cells for plotting made.
  
```{r}
  #************************************************
  #gating on Center+ ----
  #************************************************
  number_of_events_before_center_gating <- number_of_events_after_residual_gating
  random_events_for_plotting <- random_events(number_of_events_before_center_gating)
  
```

Center is gated in the same way as Residuals by using the function find_gaussian_gates_second_top(). Also, here we have chosen to use 10% gaussian gates for both lower and upper gate. This must be adjusted to what level you want to use for your data. Plots are made and if wanted saved in the same way as for Residuals. 



```{r, echo = FALSE, message= FALSE, comment= FALSE}
center_gates <- find_gaussian_gates_second_top(data = clean_up_data, channel = "Center", lower_gate_percent = 10, upper_gate_percent = 10)

time_signal_plots <- time_signal_plot(data = clean_up_data, random_events = random_events_for_plotting, channel = "Center", plot_title = file_names, lower_gate = center_gates$lower_gate, upper_gate = center_gates$upper_gate)
plotSignal(plot_list = time_signal_plots)

# tiff(fs::path(outFigPath, "Signal_fig3_center_gating.tiff"), width = 1800, height = 1200)
# plotSignal(plot_list = time_signal_plots)
# dev.off()

density_plots <- density_plot(data = clean_up_data, "Center", plot_title = file_names, lower_gate = center_gates$lower_gate, upper_gate = center_gates$upper_gate, maksCellsUsed = 25000)
density_plots

# tiff(fs::path(outFigPath, "fig3_center_gating.tiff"), width = 1200, height = 2000)
# print(density_plots)
# dev.off()
```

and the number of events to keep based on the center gating are updated together with the datasets fcs_data and clean_up_data. Also, the number_of_events_after_center_gating and percent lost with this gating is updated similar to the Residual gating. 

```{r, echo = FALSE, message= FALSE, comment= FALSE}
events_to_keep_after_center_gating <- events_to_keep(data = clean_up_data, channel = "Center", lower_gate = center_gates$lower_gate, upper_gate = center_gates$upper_gate)
 

  fcs_data <- update_data_based_on_events_to_keep(data = fcs_data, kept_events = events_to_keep_after_center_gating)
  clean_up_data <- update_data_based_on_events_to_keep(data = clean_up_data, kept_events = events_to_keep_after_center_gating)
  number_of_events_after_center_gating <-  number_of_events(data = fcs_data, file_names = file_names)
  percent_lost_from_full_dataset[as.character(file_names),"Center"] <- number_of_events_after_center_gating/number_of_events_raw_data * 100 #percent remaining from total
  percent_lost_each_gating[as.character(file_names),"Center"] <-number_of_events_after_center_gating/number_of_events_before_center_gating * 100 #percent remaining from residual gating

  
  
```

The percent of events lost for this gating is 

```{r}
percent_lost_each_gating[as.character(file_names), "Center"]
```

# Gating on Offset


The third clean up gating is on offset.

First the number of events left before this gating are found and a new set of random cells for plotting made.
  
```{r}
#************************************************
#gating on Offset+ ----
#************************************************
number_of_events_before_offset_gating <-  number_of_events_after_center_gating
random_events_for_plotting <- random_events(number_of_events_before_offset_gating)
```

Also offset is gated in the same way as Residuals and Center by using the function find_gaussian_gates_second_top(). But here we have chosen to using 18 % gaussian gates for both lower and upper gate. This must be adjusted to what level you want to use for your data. Plots are made and if wanted saved in the same way as for Residuals. 

```{r}
#update lower_gate_percent, upper_gate_percent
offset_gates <- find_gaussian_gates_second_top(data = clean_up_data, channel = "Offset", lower_gate_percent = 18, upper_gate_percent = 18)

time_signal_plots <- time_signal_plot(data = clean_up_data, random_events = random_events_for_plotting, channel = "Offset", plot_title = file_names, lower_gate = offset_gates$lower_gate, upper_gate = offset_gates$upper_gate)
plotSignal(plot_list = time_signal_plots)

# tiff(fs::path(outFigPath, "Signal_fig4_offset_gating.tiff"), width = 1800, height = 1200)
# plotSignal(plot_list = time_signal_plots)
# dev.off()

density_plots <- density_plot(data = clean_up_data, "Offset", plot_title = file_names, lower_gate = offset_gates$lower_gate, upper_gate = offset_gates$upper_gate, maksCellsUsed = 25000)
density_plots

# tiff(fs::path(outFigPath, "fig4_offset_gating.tiff"), width = 1200, height = 2000)
# print(density_plots)
# dev.off()
```


The number of events to keep based on the offset gating are updated together with the datasets fcs_data and clean_up_data, number_of_events_after_offset_gating and percent lost with this gating is updated similar to the previous gatings. 

```{r}
events_to_keep_after_offset_gating <- events_to_keep(data = clean_up_data, channel = "Offset",  lower_gate = offset_gates$lower_gate, upper_gate = offset_gates$upper_gate)

fcs_data <- update_data_based_on_events_to_keep(data = fcs_data, kept_events = events_to_keep_after_offset_gating)
clean_up_data <- update_data_based_on_events_to_keep(data = clean_up_data, kept_events = events_to_keep_after_offset_gating)
number_of_events_after_offset_gating <- number_of_events(data = fcs_data, file_names = file_names)
percent_lost_from_full_dataset[as.character(file_names),"Offset"] <- number_of_events_after_offset_gating/number_of_events_raw_data * 100 #percent remaining from total
percent_lost_each_gating[as.character(file_names),"Offset"] <- number_of_events_after_offset_gating/number_of_events_before_offset_gating * 100 #percent remaining from  center gating
```


The percent of events lost for this gating is 

```{r}
percent_lost_each_gating[as.character(file_names), "Offset"]
```

# Gating on Width

The fourth clean up gating is on Width

First the number of events left before this gating are found and a new set random cells for plotting made.

```{r}
#************************************************
#gating on Width+ ----
#************************************************
number_of_events_before_width_gating <-  number_of_events(data = fcs_data, file_names = file_names)
random_events_for_plotting <- random_events(number_of_events_before_width_gating)

```

Here the function find_gaussian_gates_highest_top() takes the dataset that you want to make the gates based on, here clean_up_data in column channel "Width", and two values lower_perc_height and upper_perc_height, here 0.025 and 0.04, the proportion height of the max of the density curve. The max of the density curve is here shown with the red line. while 0.025 times this height is shown with the green line, and 0.4 times the height is shown with a dark green line. The gate should be placed where the green horizontal line crosses the density curve. Here shown by the green vertical line. The function function  find_gaussian_gates_highest_top() take a list of matrices and return two vector in the same length as the list, i.e. two gate per file. 



```{r, echo = FALSE, message= FALSE, comment= FALSE}
lower_gate_prop <- 0.025
min_upper_gate <- 0
upper_gate_prop <- 0.04

xx <- clean_up_data[[1]][, "Width"]
dens <- density(xx)
ts_y <- ts(smooth(dens$y))
lower_gate <- max(min(dens$x[dens$y > max(dens$y) * lower_gate_prop]))
upper_gate <- max(c(dens$x[dens$y > max(dens$y) * upper_gate_prop], min_upper_gate), na.rm = T)

top_n <- which(dens$y == max(dens$y))

h <- max(dens$y)
cutoff_h_lower <- dens$y[min(dens$y > (max(dens$y) * lower_gate_prop))] 
cutoff_n_lower <- min(which(dens$y > (max(dens$y) * lower_gate_prop)))
cutoff_h_upper <- dens$y[bunn_n] + upper_gate_prop*h
cutoff_n_upper <- bunn_n + which(dens$y[bunn_n:length(dens$y)] > cutoff_h_upper)[1] - 1
upper_gate <- max(dens$x[dens$y > max(dens$y) * upper_gate_prop])
   

plot(dens, lwd = 3, main = "density plot Width", xlab = "arc sinh transformed signal")  
abline(v = dens$x[top_n], col = "red")
abline(h = 0, col = "red")
abline(h = dens$y[top_n], col = "red")
lines(c(5,5), c(0, dens$y[top_n]), col = "blue")   
text(x = 5.2, y =dens$y[top_n] - (dens$y[top_n] - dens$y[bunn_n])*0.5, labels = "h", col = "blue")
abline(v = lower_gate, col = "green")
abline(h = dens$y[cutoff_n_lower], col = "green")
abline(v = upper_gate, col = "darkgreen")
abline(h = dens$y[cutoff_n_upper], col = "darkgreen")


```




The find_gaussian_gates_highest_top() are used to find lower gate for the positiv signal of the width.
It takes the variables

  * data: here the arc sinh transformed clean_up_data are used
  * channel: which marker/channel you want to gate, here "Width".
  * lower_gate_percent: tells where the lower gate is placed. See figure and explanation above, here 7 %
  * upper_gate_percent: tells where the upper gate is placed. See figure and explanation above, here 7 %

R code to fine the lower and upper residual gates:

```{r}
#update lower_gate_percent, upper_gate_percent
  width_gates <- find_gaussian_gates_highest_top(data = clean_up_data, channel = "Width", lower_gate_percent = 7, upper_gate_percent = 7)

  density_plots <- density_plot(data = clean_up_data, "Width", plot_title = file_names, lower_gate = width_gates$lower_gate, upper_gate = width_gates$upper_gate, maksCellsUsed = 25000)
  density_plots


  # tiff(fs::path(outFigPath, "fig5_width_gating.tiff"), width = 1800, height = 1200)
  # print(density_plots)
  # dev.off()
  #time_signal_plots <- time_signal_plot(data = clean_up_data, random_events = random_events_for_plotting, channel = "Width", plot_title = file_names, lower_gate = width_gates$lower_gate, upper_gate = width_gates$upper_gate)
  #time_signal_plots # to see all plots
  #time_signal_plots[1] # to see first plot
  plotSignal(plot_list = time_signal_plots)
  
# tiff(fs::path(outFigPath, "Signal_fig5_width_gating.tiff"), width = 1200, height = 2000)
# plotSignal(plot_list = time_signal_plots)
# dev.off()
```

The number of events to keep based on the width gating are updated together with the datasets fcs_data and clean_up_data, number_of_events_after_offset_gating and percent lost with this gating is updated similar to the previous gatings. 

```{r}
events_to_keep_after_width_gating <- events_to_keep(data = clean_up_data, channel = "Width", lower_gate = width_gates$lower_gate, upper_gate = width_gates$upper_gate)
#   
  fcs_data <- update_data_based_on_events_to_keep(data = fcs_data, kept_events = events_to_keep_after_width_gating)
  clean_up_data <- update_data_based_on_events_to_keep(data = clean_up_data, kept_events = events_to_keep_after_width_gating)
  number_of_events_after_width_gating <- number_of_events(data = fcs_data, file_names = file_names)
  percent_lost_from_full_dataset[as.character(file_names),"Width"] <- number_of_events_after_width_gating/number_of_events_raw_data * 100 #percent remaining from total
  percent_lost_each_gating[as.character(file_names),"Width"] <- number_of_events_after_width_gating/number_of_events_before_width_gating * 100 #percent remaining from offset gating
```

The percent of events lost for this gating is 

```{r}
percent_lost_each_gating[as.character(file_names), "Width"]
```


# Gating on Event

The fifth clean up gating is on event.

First the number of events left before this gating are found and a new set random cells for plotting made.

```{r}
  #************************************************
  #gating on Event+ ----
  #************************************************
  number_of_events_before_event_gating <-  number_of_events(data = fcs_data, file_names = file_names)
  random_events_for_plotting <- random_events(number_of_events_before_event_gating)

```

Also event is gated by using the function find_gaussian_gates_second_top(). But here we have chosen to include less of the data using 20 % gaussian gates for both lower and upper gate. This must be adjusted to what level you want to use for your data. Plots are made and if wanted saved in the same way as for Residuals. 

```{r}
#update lower_gate_percent, upper_gate_percent
  EventGates <- find_gaussian_gates_second_top(data = clean_up_data, channel = "Event_length", lower_gate_percent = 20, upper_gate_percent = 20)
  density_plots <- density_plot(data = clean_up_data, "Event_length", plot_title = file_names, lower_gate = EventGates$lower_gate, upper_gate = EventGates$upper_gate, maksCellsUsed = 25000)
  density_plots


  # tiff(fs::path(outFigPath, "fig6_event_gating.tiff"), width = 1800, height = 1200)
  # print(density_plots)
  # dev.off()
  time_signal_plots <- time_signal_plot(data =  clean_up_data, random_events = random_events_for_plotting, channel = "Event_length", plot_title = file_names, lower_gate = EventGates$lower_gate, upper_gate = EventGates$upper_gate)
  #time_signal_plots # to see all plots
  #time_signal_plots[1] # to see first plot
  
  plotSignal(plot_list = time_signal_plots)
  
  # tiff(fs::path(outFigPath, "Signal_fig6_event_gating.tiff"), width = 1200, height = 2000)
  # plotSignal(plot_list = time_signal_plots)
  # dev.off()

```

The number of events to keep based on the event gating are updated together with the datasets fcs_data and clean_up_data, number_of_events_after_offset_gating and percent lost with this gating is updated similar to the previous gatings. 


```{r}
events_to_keep_after_event_gating <- events_to_keep(data = clean_up_data, channel = "Event_length",  upper_gate = EventGates$upper_gate)
  #percent_to_keep_this_gating(kept_events = events_to_keep_after_event_gating, file_names = file_names)

fcs_data <- update_data_based_on_events_to_keep(data = fcs_data, kept_events = events_to_keep_after_event_gating)
  clean_up_data <- update_data_based_on_events_to_keep(data = clean_up_data, kept_events = events_to_keep_after_event_gating)
  number_of_events_after_event_gating <-  number_of_events(data = fcs_data, file_names = file_names)
  percent_lost_from_full_dataset[as.character(file_names),"Event_length"] <- number_of_events_after_event_gating/number_of_events_raw_data * 100 #percent remaining from total
  percent_lost_each_gating[as.character(file_names),"Event_length"] <- number_of_events_after_event_gating/number_of_events_before_event_gating * 100 #percent remaining from width gating
```

The percent of events lost for this gating is 

```{r}
percent_lost_each_gating[as.character(file_names), "Event_length"]
```


# Gating on CIS

The sixth clean up gating is on CIS, live cells.

First the number of events left before this gating are found and a new set random cells for plotting made.

```{r}
#************************************************
  #gating on Live Dead----  Cis,
  #************************************************
  number_of_events_before_cis_gating <-  number_of_events(data = fcs_data, file_names = file_names)
  random_events_for_plotting <- random_events(number_of_events_before_cis_gating)
```

Also CIS is gated by using the function find_gaussian_gates_second_top(). But here we have chosen to use 5 % gaussian gates for the lower gate and 20 % for the upper gate. This must be adjusted to what level you want to use for your data. Plots are made and if wanted saved in the same way as for Residuals. 

```{r}
#update lower_gate_percent, upper_gate_percent
  cis_gates <- find_gaussian_gates_second_top(data = clean_up_data, channel = "Pt194Di", lower_gate_percent = 5, upper_gate_percent = 30)
# if you want to overwrite the gate found this could be done like this:
 # tvungetLavereCISgate <- 0.5 #sett inn NA hvis du heller vil bruke gaussian gate for CIS. evt annet tall..
 # if(!is.na(tvungetLavereCISgate)){
#   cis_gates$lower_gates <- rep(tvungetLavereCISgate, length(cis_gates$lower_gates))
# }

  density_plots <- density_plot(data = clean_up_data, "Pt194Di", plot_title = file_names, lower_gate = cis_gates$lower_gate, upper_gate = cis_gates$upper_gate, maksCellsUsed = 25000)
  density_plots


  # tiff(fs::path(outFigPath, "fig7_cis_gating.tiff"), width = 1800, height = 1200)
  # print(density_plots)
  # dev.off()
  time_signal_plots <- time_signal_plot(data = clean_up_data, random_events = random_events_for_plotting, channel = "Pt194Di", plot_title = file_names, lower_gate = cis_gates$lower_gate, upper_gate = cis_gates$upper_gate)
  #time_signal_plots # to see all plots
  #time_signal_plots[1] # to see first plot
  #time_signal_plots <- time_signal_plot(data = clean_up_data, random_events = random_events_for_plotting, channel = "Pt194Di", plot_title = file_names, lower_gate = NA, upper_gate = NA)
  #time_signal_plots # to see all plots
  
   plotSignal(plot_list = time_signal_plots)
  
  # tiff(fs::path(outFigPath, "Signal_fig7_cis_gating.tiff"), width = 1200, height = 2000)
  # plotSignal(plot_list = time_signal_plots)
  # dev.off()
```

The number of events to keep based on the cis gating are updated together with the datasets fcs_data and clean_up_data, number_of_events_after_offset_gating and percent lost with this gating is updated similar to the previous gatings. 

```{r}
events_to_keep_after_cis_gating <- events_to_keep(data = clean_up_data, channel = "Pt194Di",  lower_gate = cis_gates$lower_gate,  upper_gate = cis_gates$upper_gate)


  fcs_data <- update_data_based_on_events_to_keep(data = fcs_data, kept_events = events_to_keep_after_cis_gating)
  clean_up_data <- update_data_based_on_events_to_keep(data = clean_up_data, kept_events = events_to_keep_after_cis_gating)
  number_of_events_after_cis_gating <-  number_of_events(data = fcs_data, file_names = file_names)
  percent_lost_from_full_dataset[as.character(file_names),"Pt194Di"] <- number_of_events_after_cis_gating/number_of_events_raw_data * 100 #percent remaining from total
  percent_lost_each_gating[as.character(file_names),"Pt194Di"] <- number_of_events_after_cis_gating/number_of_events_before_cis_gating * 100 #percent remaining from event gating
```

The percent of events lost for this gating is 

```{r}
percent_lost_each_gating[as.character(file_names), "Pt194Di"]
```

# gating on DNA1, Ir 191

This is the last and seventh clean up gating.

First the number of events left before this gating are found and a new set random cells for plotting made.


```{r}
#************************************************
  #gating on DNA1, Ir191Di+ ----
  #************************************************
  number_of_events_before_Ir191Di_gating <-  number_of_events(fcs_data, file_names = file_names)
  random_events_for_plotting <- random_events(number_of_events_before_Ir191Di_gating)
```


Also, here gaussian gate for the second top is found, but instead of using the variables lower_gate_percent and upper_gate_percent another variable is used. This is perc_include. In this version of the function, we assume the signals to come from two normal distribution and that we want to find the gate that include 99 % of the normal distribution with the highest top. This way of finding the gates involves some computation and will take some time. The best approach is to test on some files and then run it for all files later. 

```{r, message=FALSE, warning=FALSE, comment=FALSE}
Ir191di_gates <- find_gaussian_gates_second_top(data = clean_up_data, channel = "Ir191Di", lower_gate_percent = NA, upper_gate_percent = NA, perc_included = 0.99, main_top_to_left = F)

density_plots <- density_plot(data = clean_up_data, "Ir191Di", plot_title = file_names, lower_gate = Ir191di_gates$lower_gate, upper_gate = Ir191di_gates$upper_gate, maksCellsUsed = 25000)

density_plots
# tiff(fs::path(outFigPath, "fig8_Ir191_gating.tiff"), width = 1800, height = 1200)
# print(density_plots)
# dev.off()
time_signal_plots <- time_signal_plot(data = clean_up_data, random_events = random_events_for_plotting, channel = "Ir191Di", plot_title = file_names, lower_gate = Ir191di_gates$lower_gate, upper_gate = Ir191di_gates$upper_gate)
#time_signal_plots # to see all plots
#time_signal_plots[1] # to see first plot


plotSignal(plot_list = time_signal_plots)
  
# tiff(fs::path(outFigPath, "Signal_fig8_Ir191_gating.tiff"), width = 1200, height = 2000)
# plotSignal(plot_list = time_signal_plots)
# dev.off()
```


```{r}
events_to_keep_after_Ir191Di_gating <- events_to_keep(data = clean_up_data, channel = "Ir191Di",  lower_gate = Ir191di_gates$lower_gate,  upper_gate = Ir191di_gates$upper_gate)
  #percent_to_keep_this_gating(kept_events = events_to_keep_after_Ir191Di_gating, file_names = file_names)


fcs_data <- update_data_based_on_events_to_keep(data = fcs_data, kept_events = events_to_keep_after_Ir191Di_gating)
clean_up_data <- update_data_based_on_events_to_keep(data = clean_up_data, kept_events = events_to_keep_after_Ir191Di_gating)
number_of_events_after_Ir191Di_gating <-  number_of_events(data = fcs_data, file_names = file_names)
percent_lost_from_full_dataset[as.character(file_names),"Ir191Di"] <- number_of_events_after_Ir191Di_gating/number_of_events_raw_data * 100 #percent remaining from total
percent_lost_each_gating[as.character(file_names),"Ir191Di"] <- number_of_events_after_Ir191Di_gating/number_of_events_before_Ir191Di_gating * 100 #percent remaining from cis gating
```

The percent of events lost for this gating is 

```{r}
percent_lost_each_gating[as.character(file_names), "Ir191Di"]
```


# gating on DNA1, Ir 193

It is optional to also gate on the second DNA1 channel. 
First the number of events left before this gating are found and a new set random cells for plotting made.

```{r}
#************************************************
  #gating on DNA1, Ir193Di+ ----
  #************************************************
  number_of_events_before_Ir193Di_gating <-  number_of_events(fcs_data, file_names = file_names)
  random_events_for_plotting <- random_events(number_of_events_before_Ir193Di_gating)
```

Here we use another function called find_gaussian_gates_highest_top() which again take the variables lower_gate_percent and upper_gate_percent. 

```{r}
#update lower_gate_percent, upper_gate_percent
  Ir193di_gates <- find_gaussian_gates_highest_top(data = clean_up_data, channel = "Ir193Di", lower_gate_percent = 15, upper_gate_percent = 5)


density_plots <- density_plot(data = clean_up_data, "Ir193Di", plot_title = file_names, lower_gate = Ir193di_gates$lower_gate, upper_gate = Ir193di_gates$upper_gate, maksCellsUsed = 25000)

density_plots

# tiff(fs::path(outFigPath, "fig9_Ir193_gating.tiff"), width = 1800, height = 1200)
# print(density_plots)
# dev.off()#density_plots

time_signal_plots <- time_signal_plot(data = clean_up_data, random_events = random_events_for_plotting, channel = "Ir193Di", plot_title = file_names, lower_gate = Ir193di_gates$lower_gate, upper_gate = Ir193di_gates$upper_gate)
#time_signal_plots # to see all plots
#time_signal_plots[1] # to see first plot



plotSignal(plot_list = time_signal_plots)
  
# tiff(fs::path(outFigPath, "Signal_fig9_Ir193_gating.tiff"), width = 1200, height = 2000)
# plotSignal(plot_list = time_signal_plots)
# dev.off()
```


```{r}
events_to_keep_after_Ir193Di_gating <- events_to_keep(data = clean_up_data, channel = "Ir193Di",  lower_gate = Ir193di_gates$lower_gate,  upper_gate = Ir193di_gates$upper_gate)
  #percent_to_keep_this_gating(kept_events = events_to_keep_after_Ir193Di_gating, file_names = file_names)


  fcs_data <- update_data_based_on_events_to_keep(data = fcs_data, kept_events = events_to_keep_after_Ir193Di_gating)
  clean_up_data <- update_data_based_on_events_to_keep(data = clean_up_data, kept_events = events_to_keep_after_Ir193Di_gating)
  number_of_events_after_Ir193Di_gating <-  number_of_events(data = fcs_data, file_names = file_names)
  percent_lost_from_full_dataset[as.character(file_names),"Ir193Di"] <- number_of_events_after_Ir193Di_gating/number_of_events_raw_data * 100 #percent remaining from total
  percent_lost_each_gating[as.character(file_names),"Ir193Di"] <- number_of_events_after_Ir193Di_gating/number_of_events_before_Ir193Di_gating * 100 #percent remaining from cis gating
```

The percent of events lost for this gating is 

```{r}
percent_lost_each_gating[as.character(file_names), "Ir193Di"]
```

The last ting to do is to save the clean files. 

```{r}
#************************************************
  #save fcs_data ----
  #************************************************

  flowCore::write.flowSet(fcs_data, outdir = outDataPath, filename = as.character(file_names))
```

and the amount of the files lost during gating. 

```{r}
 write.csv2(percent_lost_each_gating, fs::path(out_result, "percent_kept_each_gatingnr2.csv"))
 write.csv2(percent_lost_from_full_dataset, fs::path(out_result, "percent_kept_from_full_datasetnr2.csv"))


```

